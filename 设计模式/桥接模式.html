<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
	</body>
	<script type="text/javascript">
		//解决 个浏览器 http 请求差异问题
		var asyncRequest = (function(){
			function handleReadyState(o,callback){
				var poll = window.setInterval(function(){
					if(o && o.readyState == 4){
						window.clearInterval(poll);
						if(callback){
							callback(0);
						}
					}
				},50)
			}
			var getXHR = function(){
				var http ;
				try{
					http = new XMLHttpRequest;
					getXHR = function(){
						return new XMLHttpRequest;
					}
				}catch(e){
					//TODO handle the exception
					var msxml = [
						'MSXML2.XMLHTP.3.0',
						'MSXML2.XMLHTP',
						'Microsoft.XMLHTP'
					];
					for(var i=0;i<msxml.length;i++){
						try{
							http = new ActiveXObject(msxml[i]);
							getXHR = function(){
								return new ActiveXObject(msxml[i]);
							}
							break;
						}catch(e){
							//TODO handle the exception
						}
					}
				}
				return http;
			}
			return function(method,uri,callback,postData){
				var http = getXHR();
				http.open(method,uri,true);
				handleReadyState(http,callback);
				http.send(postData || null);
				return http;
			}
		})()
		//链式调用
		Function.prototype.method = function(name,fn){
			this.prototype[name] = fn;
			return this;
		}
		//给数组添加 forEach 和 filter 方法
		if(!Array.prototype.forEach){
			Array.method('forEach',function(fn,thisObj){
				var scope = thisObj || window;
				for(var i=0;i<this.length;i++){
					fn.call(scope,this[i],i,this);
				}
			})
		}
		if(!Array.prototype.filter){
			Array.method('filter',function(fn,thisObj){
				var scope = thisObj || window;
				var a = [];
				for(var i=0;i<thisObj.length;i++){
					if(!fn.call(scope,this[i],i,this)){
						continue;
					}
					a.push(this[i]);
				}
				return a;
			})
		}
		//观察者系统
		window.DED = window.DED || {};
		DED.util = DED.util || {};
		DED.util.Observer = function(){
			this.fns = [];
		}
		DED.util.Observer.prototype = {
			subscribe:function(fn){
				this.fns.push(fn);
			},
			unsubscribe:function(fn){
				this.fns = this.fns.filter(function(el){
					if(el != fn){
						return el;
					}
				})
			},
			fire:function(o){
				this.fns.forEach(function(el){
					el(o)
				})
			}
		}
		
		DED.Queue = function(){
			this.queue = [];
			
			this.onComplete = new DED.util.Observer;
			this.onFailure = new DED.util.Observer;
			this.onFlush = new DED.util.Observer;
			
			this.retryCount = 3;
			this.currentRetry = 0;
			this.paused = false;
			this.timeout = 5000;
			this.conn = {};
			this.timer = {};
		};
		DED.Queue.method('flush',function(){
			if(!this.queue.length>0){
				return;
			}
			if(this.paused){
				this.paused = false;
				return;
			}
			var that = this;
			this.currentRetry++;
			var abort = function(){
				if(that.currentRetry == thar.retryCount){
					that.onFailure.fire();
					that.currentRetry = 0;
				}else{
					that.flush();
				}
			}
			this.timer = window.setTimeout(abort,this.timeout);
			var callback = function(o){
				window.clearTimeout(that.timer);
				that.currentRetry = 0;
				that.queue.shift();
				that.onFlush.fire(o.responseText);
				if(that.queue.length==0){
					that.onComplete.fire();
					return;
				}
				that.flush();
			}
			this.conn = asyncRequest(
				this.queue[0]['method'],
				this.queue[0]['uri'],
				callback,
				this.queue[0]['params'],
			);
		}).method('setRetryCount',function(count){
			this.retryCount = count;
		}).method('setTimeout',function(time){
			this.timeout = time;
		}).method('add',function(o){
			this.queue.push(o);
		}).method('pause',function(){
			this.paused = true;
		}).method('dequeue',function(){
			this.queue.pop();
		}).method('clear',function(){
			this.queue= [];
		})
		//实现
		var q = new DED.Queue;
		q.add({
			method:'get',
			uri:'/path/to/test'
		})
		console.log(q)
		q.flush();
	</script>
</html>
